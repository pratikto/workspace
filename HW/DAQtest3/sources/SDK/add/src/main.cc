#include <stdio.h>
#include "platform.h"
#include "xil_printf.h"
/*
 * Several BSP (and standard C) header files need to be included
 */
#include <stdlib.h> // Standard C functions, e.g. exit()
#include <stdbool.h> // Provides a Boolean data type for ANSI/ISO-C
#include "xparameters.h" // Parameter definitions for processor peripherals
#include "xscugic.h" // Processor interrupt controller device driver
#include "xadd.h" // Device driver for HLS HW block


/*
 * Parameter definitions
 */
#define use_interrupt 	1				//HLS interrupt
#define IntrMask		1
/*
 * Define variables for the HLS block and interrupt controller instance data. The variables
 * will be passed to driver API calls as handles in the respective hardware.
 */
XAdd HlsAdd;				// HLS Add HW instance
XScuGic ScuGic;						//Interrupt Controller Instance
XScuGic_Config *ScuGic_cfg_ptr;


/*
 * Define global variables to interface with the interrupt service routine (ISR).
 */
volatile static int RunHls = 0;
volatile static int ResultAvailHls = 0;
u64 X, Y, Z;
bool ready_A, ready_B;

/*
 * Function declaration
 */
void addHW(
//		u64 a,
//		u64 b,
//		u64 c,
//		bool ready_A,
//		bool ready_B
		);

int hls_init(XAdd *hls_maccPtr);
void hls_start(void *InstancePtr);
void hls_isr(void *InstancePtr);
int interrupt_init(
		XScuGic_Config 	*intr_cfg_ptr,
		XScuGic 		*intr_ptr,			//Interrupt Controller Instance
		XAdd 		*Add_ptr);		//HLS Add HW instance

/*
 * Modify main() to use the HLS device driver API and the functions defined above to test
 * the HLS peripheral hardware
 */
int main()
{
	print("Program to test communication with HLS Add peripheral in PL\n\r");
//	u64 a, b, c;
//	bool ready_A, ready_B;
	int status;
	char* buffer;

	//Setup the coprocessor
	status = hls_init(&HlsAdd);
	if(status != XST_SUCCESS){
		print("HLS peripheral setup failed\n\r");
		exit(-1);
	}

	//Setup the interrupt
	status = interrupt_init(ScuGic_cfg_ptr, &ScuGic, &HlsAdd);
	if(status != XST_SUCCESS){
		print("Interrupt setup failed\n\r");
		exit(-1);
	}

	while(true){
		addHW(/*a,b,c, ready_A, ready_B*/);
		sprintf(buffer, "A = %u\tB = %u\tC = %u\n", X, Y, Z);
		print(buffer);
	}
	return 0;
}

/*
 * Define a function to wrap all run-once API initialization function calls for the HLS block.
 */
int hls_init(XAdd *hls_maccPtr){
	XAdd_Config *cfgPtr;
	int status;
	cfgPtr = XAdd_LookupConfig(XPAR_ADD_0_DEVICE_ID);	//Obtain the configuration information of the device by ID.
	if (!cfgPtr) {
		print("ERROR: Lookup of accelerator configuration failed.\n\r");
		return XST_FAILURE;
	}
	/*
	 * Initialize a device when an MMU is used in the system. In such a case the effective address
	 * of the AXI4-Lite slave is different from that defined in xparameters.h and API is required to
	 * initialize the device.
	 */
	status = XAdd_CfgInitialize(hls_maccPtr, cfgPtr);
	if (status != XST_SUCCESS) {
		print("ERROR: Could not initialize accelerator.\n\r");
		return XST_FAILURE;
	}
	return status;
}

/*
 * Define a helper function to wrap the HLS block API calls required to enable its interrupt
 * and start the block.
 */
void hls_start(void *InstancePtr){
	XAdd *pAccelerator = (XAdd *)InstancePtr; //hold the IP instance pointer
	/*
	 * Enable the interrupt source. There may be at most 2 interrupt sources (source 0 for ap_done
	 * and source 1 for ap_ready)
	 */
	//bit 0 => ap_done
	//bit 1 => ap_start
	XAdd_InterruptEnable(pAccelerator,IntrMask);
	/*
	 * Enable the interrupt output. Interrupt functions are available only if there is ap_start.
	 */
	XAdd_InterruptGlobalEnable(pAccelerator);
	/*
	 * Start the device. This function will assert the ap_start port on the device. Available only
	 * if there is ap_start port on the device
	 */
	XAdd_Start(pAccelerator);
}

/*
 * An interrupt service routine is required in order for the processor to respond to an interrupt
 * generated by a peripheral.
 *
 * Each peripheral with an interrupt attached to the PS must have an ISR defined and
 * registered with the PS’s interrupt handler.
 *
 * The ISR is responsible for clearing the peripheral’s interrupt and, in this example, setting a
 * flag that indicates that a result is available for retrieval from the peripheral. In general, ISRs
 * should be designed to be lightweight and as fast as possible, essentially doing the
 * minimum necessary to service the interrupt. Tasks such as retrieving the data should be left
 * to the main application code.
 */
void hls_isr(void *InstancePtr){
	XAdd *pAccelerator = (XAdd *)InstancePtr;
	//Disable the global interrupt
	XAdd_InterruptGlobalDisable(pAccelerator);
	//Disable the local interrupt
	XAdd_InterruptDisable(pAccelerator,0xffffffff);
	// clear the local interrupt
	XAdd_InterruptClear(pAccelerator, IntrMask);
	ResultAvailHls = 1;
	// restart the core if it should run again
	if(RunHls){
		hls_start(pAccelerator);
	}
}

/*
 * Define a routine to setup the PS interrupt handler and register the HLS peripheral’s ISR.
 * This functions sets up the interrupt on the ARM.
 */
int interrupt_init(
		XScuGic_Config 	*intr_cfg_ptr,
		XScuGic 		*intr_ptr,			//Interrupt Controller Instance
		XAdd 			*Add_ptr		//HLS Add HW instance
		){

	/*
	 * Initialise the GIC driver
	 */

	int result;

	intr_cfg_ptr= XScuGic_LookupConfig(XPAR_SCUGIC_SINGLE_DEVICE_ID);
	if (intr_cfg_ptr == NULL){
		print("Interrupt Configuration Lookup Failed\n\r");
		return XST_FAILURE;
	}

	result = XScuGic_CfgInitialize(
			intr_ptr,
			intr_cfg_ptr,
			intr_cfg_ptr->CpuBaseAddress);
	if(result == XST_FAILURE){
		print("Interrupt initialization Configuration Failed\n\r");
		return result;
	}

	// self-test
	result = XScuGic_SelfTest(intr_ptr);
	if(result == XST_FAILURE){
		print("Self test Failed\n\r");
		return result;
	}

	// Initialize the exception handler
	Xil_ExceptionInit();

	// Register the exception handler
	Xil_ExceptionRegisterHandler(
			XIL_EXCEPTION_ID_INT,
			(Xil_ExceptionHandler)XScuGic_InterruptHandler,
			intr_ptr);

	//Enable the exception handler
	Xil_ExceptionEnable();

	/*
	 * Connect the Adder ISR to the exception table
	 */

	//Connect HLS Add interrupt to handler
	result = XScuGic_Connect(
			intr_ptr,
			XPAR_FABRIC_ADD_0_INTERRUPT_INTR,
			(Xil_InterruptHandler)hls_isr,
			 Add_ptr);

	if(result != XST_SUCCESS){
		xil_printf("HLS Add ISR connection failed!");
		return result;
	}
	//Enable HLS Add interrupts in the controller
	XScuGic_Enable(intr_ptr,XPAR_FABRIC_ADD_0_INTERRUPT_INTR);

	if(result != XST_SUCCESS){
		xil_printf("HLS Add ISR connection failed!");
		return result;
	}

	return XST_SUCCESS;
}

void addHW(
//		u64 a,
//		u64 b,
//		u64 c,
//		bool ready_A,
//		bool ready_B
		)
{

	if (not XAdd_IsReady(&HlsAdd)){
   		print("!!! HLS peripheral is not ready! Exiting...\n\r");
   		exit(-1);
   	}

   	if (use_interrupt) { // use interrupt
   		hls_start(&HlsAdd);
//   		XTmrCtr_Start(&timer, timer0);
   		while(!ResultAvailHls)
   			; // spin
   		ResultAvailHls = 0;

   		ready_A = XAdd_Get_A_ready_out(&HlsAdd);
   		ready_B = XAdd_Get_B_ready_out(&HlsAdd);

   		if (ready_A && ready_B){
   			X = XAdd_Get_A_out_V(&HlsAdd);
	   		Y = XAdd_Get_B_out_V(&HlsAdd);
	   		Z = XAdd_Get_C_out_V(&HlsAdd);
   		}

   	}
   	else {
   		// Simple non-interrupt driven test
   		XAdd_Start(&HlsAdd);
   		do {
   	   		ready_A = XAdd_Get_A_ready_out(&HlsAdd);
   	   		ready_B = XAdd_Get_B_ready_out(&HlsAdd);

   	   		X = XAdd_Get_A_out_V(&HlsAdd);
		   	Y = XAdd_Get_B_out_V(&HlsAdd);
		   	Z = XAdd_Get_C_out_V(&HlsAdd);

//   	   		if (ready_A && ready_B){
//   	   			X = XAdd_Get_A_out_V(&HlsAdd);
//   		   		Y = XAdd_Get_B_out_V(&HlsAdd);
//   		   		Z = XAdd_Get_C_out_V(&HlsAdd);
//   	   		}
   		} while (!XAdd_IsReady(&HlsAdd));
   		print("Detected HLS peripheral complete. Result received.\n\r");
   	}
}
